

--- HISTORIA DE USUARIO ---
- id: HDU002
  title: Crear y gestionar skills asociados a categorías
  descripcion: Como administrador, quiero poder definir skills técnicos (como Java,
    Jenkins, Docker) agrupados en categorías, para luego asignarlos a roles.
  entidad: Skill
  campos:
  - id
  - nombre
  - categoria_id
  acciones:
  - POST
  - GET
  - PUT
  - DELETE
  validaciones:
  - nombre obligatorio
  - referencia válida a categoria

--- CLASES DISPONIBLES EN EL PROYECTO ---
Categoria
CategoriaController
CategoriaRepository
CategoriaService
BackendApplication


--- CÓDIGO EXISTENTE DEL PROYECTO ---


// Archivo: src/main/java/com/skillmap/backend/model/Categoria.java

package com.skillmap.backend.model;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.validation.constraints.NotBlank;
@Entity
public class Categoria {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    @NotBlank
    private String nombre;
    public Long getId() {
        return id;
    }
    public void setId(Long id) {
        this.id = id;
    }
    public String getNombre() {
        return nombre;
    }
    public void setNombre(String nombre) {
        this.nombre = nombre;
    }
}


// Archivo: src/main/java/com/skillmap/backend/controller/CategoriaController.java

package com.skillmap.backend.controller;
import com.skillmap.backend.model.Categoria;
import com.skillmap.backend.service.CategoriaService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;
@RestController
@RequestMapping("/categorias")
public class CategoriaController {
    @Autowired
    private CategoriaService categoriaService;
    @PostMapping
    public Categoria createCategoria(@RequestBody Categoria categoria) {
        return categoriaService.createCategoria(categoria);
    }
    @GetMapping
    public Iterable<Categoria> getAllCategorias() {
        return categoriaService.getAllCategorias();
    }
    @PutMapping("/{id}")
    public Categoria updateCategoria(@PathVariable Long id, @RequestBody Categoria categoria) {
        return categoriaService.updateCategoria(id, categoria);
    }
    @DeleteMapping("/{id}")
    public void deleteCategoria(@PathVariable Long id) {
        categoriaService.deleteCategoria(id);
    }
}


// Archivo: src/main/java/com/skillmap/backend/repository/CategoriaRepository.java

package com.skillmap.backend.repository;
import com.skillmap.backend.model.Categoria;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
@Repository
public interface CategoriaRepository extends JpaRepository<Categoria, Long> {
    boolean existsByNombre(String nombre);
}


// Archivo: src/main/java/com/skillmap/backend/service/CategoriaService.java

package com.skillmap.backend.service;
import com.skillmap.backend.model.Categoria;
import com.skillmap.backend.repository.CategoriaRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
@Service
public class CategoriaService {
    @Autowired
    private CategoriaRepository categoriaRepository;
    public Categoria createCategoria(Categoria categoria) {
        if (categoriaRepository.existsByNombre(categoria.getNombre())) {
            throw new IllegalArgumentException("El nombre de la categoría ya existe");
        }
        return categoriaRepository.save(categoria);
    }
    public Iterable<Categoria> getAllCategorias() {
        return categoriaRepository.findAll();
    }
    public Categoria updateCategoria(Long id, Categoria categoria) {
        if (!categoriaRepository.existsById(id)) {
            throw new IllegalArgumentException("La categoría no existe");
        }
        if (categoriaRepository.existsByNombre(categoria.getNombre())) {
            throw new IllegalArgumentException("El nombre de la categoría ya existe");
        }
        categoria.setId(id);
        return categoriaRepository.save(categoria);
    }
    public void deleteCategoria(Long id) {
        if (!categoriaRepository.existsById(id)) {
            throw new IllegalArgumentException("La categoría no existe");
        }
        categoriaRepository.deleteById(id);
    }
}


// Archivo: src/main/java/com/skillmap/backend/BackendApplication.java

package com.skillmap.backend;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class BackendApplication {

	public static void main(String[] args) {
		SpringApplication.run(BackendApplication.class, args);
	}

}

--- ANÁLISIS DE CLASES EXISTENTES ---
Genera una tabla Markdown como esta:

| Clase Java | Package | Clasificación | Motivo |
|------------|---------|----------------|--------|
| Employee | com.example.EmployeeCoreApi.model | REUTILIZABLE-AS-IS | Contiene atributo `gender` |
| EmployeeServiceImpl | com.example.EmployeeCoreApi.service.impl | MODIFICABLE | Debe validar antes de borrar |
| CannotDeleteEmployeeException | com.example.EmployeeCoreApi.exception | NUEVA | Requerida para lanzar excepción |
| EmployeeServiceImplTest | com.example.EmployeeCoreApi.service.impl | NUEVA | Pruebas unitarias de validación |

--- INSTRUCCIONES DE MODIFICACIÓN ---
- No eliminar ni reemplazar lógica existente.
- Si se modifica un método, incluirlo completo con el nuevo código y lo que ya tenía.
- Solo generar clases nuevas si están indicadas como NUEVA.
- Cada clase debe estar en su package correcto, según lo indicado en la tabla.
- NO repetir clases ya existentes si no cambian.
- NO eliminar los métodos existentes a menos que sea necesario
- NO reemplazar métodos u otro contenido de las clases existentes por comentarios entre líneas
- Solo considerar como existente una clase si está listada explícitamente en "CLASES DISPONIBLES EN EL PROYECTO".
- No debes asumir la existencia de clases que no aparecen explícitamente en la sección anterior. Si alguna clase no está listada entre las clases disponibles ni aparece en el código entregado, debe considerarse INEXISTENTE y marcada como NUEVA en el análisis.
- Si una clase no aparece listada, asumir que es NUEVA.
- Si una clase herada de otra clase o importa una interfaz propia del proyecto asegúrate que esta esté entre las clases existentes o genera el código respectivo de no existir previamente

--- CÓDIGO A GENERAR ---
Devuelve solo clases Java válidas. Cada bloque debe comenzar con `package ...`.
Incluye los tests JUnit5 en el mismo formato si aplica.
