name: Build + Sonar + Informe

on:
  push:
    branches:
      - main
    paths-ignore:
      - 'salida/**'
      - '.github/workflows/**'
      - 'historias-usuario/**'
      - 'postman/**' 
      
jobs:
  build-and-sonar:
    runs-on: ubuntu-latest
    env:
      SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
      GH_PAT: ${{ secrets.GH_PAT }}
      SONAR_PROJECT_KEY: rodrigorojas2B_skillMap
      SONAR_ORGANIZATION: rodrigorojas2b

    steps:
      - name: Checkout código
        uses: actions/checkout@v3
        with:
          token: ${{ secrets.GH_PAT }}

      - name: Instalar Java
        uses: actions/setup-java@v3
        with:
          distribution: 'temurin'
          java-version: '17'

      - name: Diagnóstico de fuentes presentes
        run: |
            echo "== Archivos .java =="
            find . -name "*.java"
            echo "== Archivos .class =="
            find . -name "*.class"

      - name: Generar colección Postman desde controllers
        run: |
              set -e
              mkdir -p postman
              python3 - <<'PY'
              import os, re, json, pathlib, sys
              SRC = pathlib.Path("src/main/java")
              OUT = pathlib.Path("postman/skillmap.postman_collection.json")
              OUT.parent.mkdir(parents=True, exist_ok=True)
    
              def clean(s):
                  s = s.strip()
                  if (s.startswith('"') and s.endswith('"')) or (s.startswith("'") and s.endswith("'")):
                      return s[1:-1]
                  return s
    
              def norm(p):
                  if not p: return ""
                  p = p if p.startswith("/") else "/"+p
                  return re.sub(r"/{2,}", "/", p)
    
              def join(a,b):
                  if not a: return norm(b or "/")
                  if not b: return norm(a)
                  return norm(a.rstrip("/") + "/" + b.lstrip("/"))
    
              # --- helpers para extraer paths en anotaciones ---
              # Busca value|path="..."  | value|path={"...","..."} | 1er string posicional "..."
              def first_path(args:str)->str:
                  if not args: return ""
                  m = re.search(r'(?:\bvalue\b|\bpath\b)\s*=\s*(["\'])(.+?)\1', args, re.S)
                  if m: return clean(m.group(2))
                  m = re.search(r'(?:\bvalue\b|\bpath\b)\s*=\s*\{(.*?)\}', args, re.S)
                  if m:
                      q = re.search(r'(["\'])(.+?)\1', m.group(1))
                      if q: return clean(q.group(2))
                  q = re.search(r'(["\'])(.+?)\1', args, re.S)  # posicional
                  if q: return clean(q.group(2))
                  return ""
    
              def verbs_in_requestmapping(args:str):
                  # Devuelve lista de verbos (GET,POST,...) si hay method=RequestMethod.X {,…}
                  if not args: return []
                  vs = re.findall(r'RequestMethod\.([A-Z]+)', args)
                  return [v.upper() for v in vs]
    
              # --- patrones para encontrar anotaciones ---
              re_class      = re.compile(r'\bpublic\s+(?:abstract\s+|final\s+)?class\s+([A-Za-z_]\w*)')
              re_controller = re.compile(r'@\s*(?:RestController|Controller)\b')
              re_ann        = lambda name: re.compile(r'@'+name+r'\s*(?:\((?P<args>.*?)\))?', re.S)
    
              GET = re_ann('GetMapping'); POST = re_ann('PostMapping'); PUT = re_ann('PutMapping')
              DELETE = re_ann('DeleteMapping'); PATCH = re_ann('PatchMapping')
              REQ = re_ann('RequestMapping')
    
              items = []
    
              if SRC.exists():
                  for f in SRC.rglob('*Controller.java'):
                      txt = f.read_text(encoding='utf-8', errors='ignore')
                      if not re_controller.search(txt):  # seguridad
                          continue
    
                      mcls = re_class.search(txt)
                      cname = mcls.group(1) if mcls else f.stem
    
                      # Prefijo de clase: primer @RequestMapping antes de la declaración de class
                      class_prefix = ""
                      head = txt[:mcls.start()] if mcls else txt
                      mhead = REQ.search(head)
                      if mhead:
                          class_prefix = norm(first_path(mhead.group('args')))
    
                      def collect(name, regex, verb_fixed=None):
                          for mm in regex.finditer(txt):
                              args = mm.group('args') or ""
                              path = first_path(args)
                              full = join(class_prefix, path)
                              if verb_fixed:
                                  items.append((cname, verb_fixed, full))
                              else:
                                  vs = verbs_in_requestmapping(args)
                                  if vs:
                                      for v in vs:
                                          items.append((cname, v, full))
    
                      collect('GetMapping', GET, 'GET')
                      collect('PostMapping', POST, 'POST')
                      collect('PutMapping', PUT, 'PUT')
                      collect('DeleteMapping', DELETE, 'DELETE')
                      collect('PatchMapping', PATCH, 'PATCH')
                      collect('RequestMapping', REQ, None)   # usa method=RequestMethod.*
    
              # Construir colección Postman
              from collections import defaultdict
              groups = defaultdict(list)
              for cname, verb, path in sorted(set(items), key=lambda x:(x[0],x[1],x[2])):
                  groups[cname].append((verb, path))
    
              coll = {
                  "info": {
                      "name": "SkillMap API (auto)",
                      "_postman_id": "auto-generated",
                      "schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json"
                  },
                  "item": [],
                  "variable": [{"key":"baseUrl","value":"http://localhost:8080"}]
              }
    
              def to_item(verb, path):
                  raw = "{{baseUrl}}" + norm(path or "/")
                  return {
                      "name": f"{verb} {norm(path or '/')}",
                      "request": {
                          "method": verb,
                          "header": [{"key":"Accept","value":"application/json"}],
                          "url": {
                              "raw": raw,
                              "host": ["{{baseUrl}}"],
                              "path": [p for p in norm(path or "/").split('/') if p]
                          }
                      }
                  }
    
              if groups:
                  for cname, routes in groups.items():
                      coll["item"].append({"name": cname, "item": [to_item(v,p) for v,p in routes]})
              else:
                  coll["item"] = [{"name":"(sin rutas detectadas)","item":[]}]
    
              OUT.write_text(json.dumps(coll, ensure_ascii=False, indent=2))
              print(f"[postman] Generada colección con {sum(len(v) for v in groups.values())} endpoints → {OUT}")
              PY
    

      - name: Verificar carpeta y archivo Postman
        if: always()
        run: |
          echo "== Lista postman =="
          ls -lah postman || true
          echo "== Árbol (si tree disponible) =="
          command -v tree >/dev/null && tree -a postman || true
          echo "== ¿.gitignore está ignorando postman? =="
          git check-ignore -v postman postman/*.json || echo "No está ignorado"
    

      - name: Build (captura de log)
        id: build
        run: |
            set -o pipefail
            mvn clean verify 2>&1 | tee build.log
        continue-on-error: true

      - name: Evaluar estado de build
        if: always()
        run: |
            if grep -q "\[INFO\] BUILD FAILURE" build.log; then
            echo "BUILD_FAILED=1" >> $GITHUB_ENV
            else
            echo "BUILD_FAILED=0" >> $GITHUB_ENV
            fi

      - name: SonarCloud Scan
        run: |
          mkdir -p src/test/java  # crea carpeta vacía si no existe
          mvn sonar:sonar \
            -Dsonar.projectKey=$SONAR_PROJECT_KEY \
            -Dsonar.organization=$SONAR_ORGANIZATION \
            -Dsonar.projectName="testSpring Original" \
            -Dsonar.sources=src/main/java \
            -Dsonar.tests=src/test \
            -Dsonar.java.binaries=target/classes \
            -Dsonar.scanner.force-deletion=true \
            -Dsonar.host.url=https://sonarcloud.io \
            -Dsonar.login=$SONAR_TOKEN || echo "SONAR_FAILED=1" >> $GITHUB_ENV

      - name: Obtener errores Sonar
        if: success() || failure()
        run: |
          curl -s "https://sonarcloud.io/api/issues/search?componentKeys=$SONAR_PROJECT_KEY&severities=BLOCKER,CRITICAL,MAJOR" > sonar_issues.json
          jq -c '{issues: [.issues[] | {severity, rule, message, component, line}]}' sonar_issues.json > sonar_filtered.json

      - name: Guardar resultado como JSON
        if: always()
        run: |
            mkdir -p salida
            SONAR_ERRORS=$(cat sonar_filtered.json)
            RUN_NUMBER=$GITHUB_RUN_NUMBER
            RUN_ID=$GITHUB_RUN_ID
            REPO=$GITHUB_REPOSITORY
            COMMIT=$GITHUB_SHA
            PAYLOAD_FILE="salida/resultado.json"
  
            if [[ "$BUILD_FAILED" == "1" ]]; then
              BUILD_RESULT="falló"
              BUILD_LOG=$(tail -n 100 build.log | jq -R -s .)
              echo "{
                    \"run_number\": $RUN_NUMBER,
                    \"build_result\": \"$BUILD_RESULT\",
                    \"commit\": \"$COMMIT\",
                    \"workflow_url\": \"https://github.com/$REPO/actions/runs/$RUN_ID\",
                    \"build_log\": $BUILD_LOG,
                    \"sonar_errors\": $SONAR_ERRORS
                }" > $PAYLOAD_FILE
            else
              BUILD_RESULT="ok"
              echo "{
                    \"run_number\": $RUN_NUMBER,
                    \"build_result\": \"$BUILD_RESULT\",
                    \"commit\": \"$COMMIT\",
                    \"workflow_url\": \"https://github.com/$REPO/actions/runs/$RUN_ID\",
                    \"sonar_errors\": $SONAR_ERRORS
                }" > $PAYLOAD_FILE
            fi
        
      - name: Subir JSON al repo
        run: |
              git config --global user.email "bot@example.com"
              git config --global user.name "CI Bot"
              git add salida/resultado.json
              git add -A postman           # <-- agrega la carpeta completa
              git status
              git commit -m "ci: resultado de análisis" || echo "Sin cambios para commitear"
              git push

