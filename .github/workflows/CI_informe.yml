name: Build + Sonar + Informe

on:
  push:
    branches:
      - main
    paths-ignore:
      - 'salida/**'
      - '.github/workflows/**'
      - 'historias-usuario/**'
      - 'postman/**' 
      
jobs:
  build-and-sonar:
    runs-on: ubuntu-latest
    env:
      SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
      GH_PAT: ${{ secrets.GH_PAT }}
      SONAR_PROJECT_KEY: rodrigorojas2B_skillMap
      SONAR_ORGANIZATION: rodrigorojas2b

    steps:
      - name: Checkout código
        uses: actions/checkout@v3
        with:
          token: ${{ secrets.GH_PAT }}

      - name: Instalar Java
        uses: actions/setup-java@v3
        with:
          distribution: 'temurin'
          java-version: '17'

      - name: Diagnóstico de fuentes presentes
        run: |
            echo "== Archivos .java =="
            find . -name "*.java"
            echo "== Archivos .class =="
            find . -name "*.class"

      - name: Generar colección Postman desde controllers
        run: |
          set -e
          mkdir -p postman
          python3 - <<'PY'
          import os, re, json, pathlib, sys

          SRC = pathlib.Path("src/main/java")
          OUT_DIR = pathlib.Path("postman")
          OUT_DIR.mkdir(parents=True, exist_ok=True)
          OUT_FILE = OUT_DIR / "skillmap.postman_collection.json"

          def clean_quotes(s):
              s = s.strip()
              if s.startswith('"') and s.endswith('"'): s = s[1:-1]
              if s.startswith("'") and s.endswith("'"): s = s[1:-1]
              return s

          def norm_path(p):
              if not p: return ""
              p = p.strip()
              p = p if p.startswith("/") else f"/{p}"
              return re.sub(r'//+', "/", p)

          def join_path(a, b):
              if not a: return norm_path(b or "/")
              if not b: return norm_path(a)
              return norm_path(a.rstrip("/") + "/" + b.lstrip("/"))

          re_class = re.compile(r'public\s+(?:abstract\s+|final\s+)?class\s+([A-Za-z_]\w*)')
          re_rest = re.compile(r'@\s*(?:RestController|Controller)\b')
          re_class_req = re.compile(
              r'@RequestMapping\s*\(\s*'
              r'(?:value|path)?\s*=\s*(?P<q>["\'])(?P<val>.+?)(?P=q)|'
              r'(?:path|value)\s*=\s*\{(?P<arr>[^}]+)\}|'
              r'(?P<noparms>)\s*'
              r'\)', re.S
          )
          verbs = ['Get','Post','Put','Delete','Patch']
          re_method_map = re.compile(
              r'@(?P<verb>'+ '|'.join(verbs) + r')Mapping\s*'
              r'\(\s*'
              r'(?:[^)]*?(?:value|path)\s*=\s*(?P<q>["\'])(?P<val>.+?)(?P=q)[^)]*|'
              r'[^)]*?)'
              r'\)', re.S
          )
          re_reqmap_method = re.compile(
              r'@RequestMapping\s*\(\s*[^)]*?method\s*=\s*RequestMethod\.(?P<verb>[A-Z]+)[^)]*?'
              r'(?:value|path)\s*=\s*(?P<q>["\'])(?P<val>.+?)(?P=q)[^)]*\)', re.S
          )

          items = []
          if not SRC.exists():
              print("WARN: No existe src/main/java. Se creará colección vacía.", file=sys.stderr)
          else:
              for java in SRC.rglob("*Controller.java"):
                  try:
                      txt = java.read_text(encoding="utf-8", errors="ignore")
                  except Exception as e:
                      print(f"WARN: No se pudo leer {java}: {e}", file=sys.stderr)
                      continue
                  if not re_rest.search(txt):
                      continue
                  m_class = re_class.search(txt)
                  class_name = m_class.group(1) if m_class else java.stem
                  pre_class = txt[:m_class.start()] if m_class else txt
                  m_cls_req = re_class_req.search(pre_class)
                  class_prefix = ""
                  if m_cls_req:
                      if m_cls_req.group("val"):
                          class_prefix = clean_quotes(m_cls_req.group("val"))
                      elif m_cls_req.group("arr"):
                          first = m_cls_req.group("arr").split(",")[0].strip()
                          class_prefix = clean_quotes(first)
                      class_prefix = norm_path(class_prefix)
                  for mm in re_method_map.finditer(txt):
                      verb = mm.group("verb").upper()
                      path = clean_quotes(mm.group("val") or "")
                      items.append((class_name, verb, join_path(class_prefix, path)))
                  for mm in re_reqmap_method.finditer(txt):
                      verb = mm.group("verb").upper()
                      path = clean_quotes(mm.group("val") or "")
                      items.append((class_name, verb, join_path(class_prefix, path)))

          coll = {
              "info": {
                  "name": "SkillMap API (auto)",
                  "_postman_id": "auto-generated",
                  "schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json"
              },
              "item": [],
              "variable": [{"key":"baseUrl","value":"http://localhost:8080"}]
          }

          from collections import defaultdict
          groups = defaultdict(list)
          for cname, verb, path in sorted(set(items), key=lambda x:(x[0],x[1],x[2])):
              groups[cname].append((verb, path))

          def to_item(verb, path):
              raw = "{{baseUrl}}" + norm_path(path or "/")
              return {
                  "name": f"{verb} {norm_path(path or '/')}",
                  "request": {
                      "method": verb,
                      "header": [{"key":"Accept","value":"application/json"}],
                      "url": {
                          "raw": raw,
                          "host": ["{{baseUrl}}"],
                          "path": [p for p in norm_path(path or "/").split("/") if p]
                      }
                  }
              }

          if groups:
              for cname, routes in groups.items():
                  coll["item"].append({"name": cname, "item": [to_item(v,p) for v,p in routes]})
          else:
              coll["item"] = [{"name":"(sin rutas detectadas)","item":[]}]

          OUT_FILE.write_text(json.dumps(coll, indent=2, ensure_ascii=False))
          print(f"Generada colección: {OUT_FILE}")
          PY

      - name: Verificar carpeta y archivo Postman
        if: always()
        run: |
          echo "== Lista postman =="
          ls -lah postman || true
          echo "== Árbol (si tree disponible) =="
          command -v tree >/dev/null && tree -a postman || true
          echo "== ¿.gitignore está ignorando postman? =="
          git check-ignore -v postman postman/*.json || echo "No está ignorado"
    

      - name: Build (captura de log)
        id: build
        run: |
            set -o pipefail
            mvn clean verify 2>&1 | tee build.log
        continue-on-error: true

      - name: Evaluar estado de build
        if: always()
        run: |
            if grep -q "\[INFO\] BUILD FAILURE" build.log; then
            echo "BUILD_FAILED=1" >> $GITHUB_ENV
            else
            echo "BUILD_FAILED=0" >> $GITHUB_ENV
            fi

      - name: SonarCloud Scan
        run: |
          mkdir -p src/test/java  # crea carpeta vacía si no existe
          mvn sonar:sonar \
            -Dsonar.projectKey=$SONAR_PROJECT_KEY \
            -Dsonar.organization=$SONAR_ORGANIZATION \
            -Dsonar.projectName="testSpring Original" \
            -Dsonar.sources=src/main/java \
            -Dsonar.tests=src/test \
            -Dsonar.java.binaries=target/classes \
            -Dsonar.scanner.force-deletion=true \
            -Dsonar.host.url=https://sonarcloud.io \
            -Dsonar.login=$SONAR_TOKEN || echo "SONAR_FAILED=1" >> $GITHUB_ENV

      - name: Obtener errores Sonar
        if: success() || failure()
        run: |
          curl -s "https://sonarcloud.io/api/issues/search?componentKeys=$SONAR_PROJECT_KEY&severities=BLOCKER,CRITICAL,MAJOR" > sonar_issues.json
          jq -c '{issues: [.issues[] | {severity, rule, message, component, line}]}' sonar_issues.json > sonar_filtered.json

      - name: Guardar resultado como JSON
        if: always()
        run: |
            mkdir -p salida
            SONAR_ERRORS=$(cat sonar_filtered.json)
            RUN_NUMBER=$GITHUB_RUN_NUMBER
            RUN_ID=$GITHUB_RUN_ID
            REPO=$GITHUB_REPOSITORY
            COMMIT=$GITHUB_SHA
            PAYLOAD_FILE="salida/resultado.json"
  
            if [[ "$BUILD_FAILED" == "1" ]]; then
              BUILD_RESULT="falló"
              BUILD_LOG=$(tail -n 100 build.log | jq -R -s .)
              echo "{
                    \"run_number\": $RUN_NUMBER,
                    \"build_result\": \"$BUILD_RESULT\",
                    \"commit\": \"$COMMIT\",
                    \"workflow_url\": \"https://github.com/$REPO/actions/runs/$RUN_ID\",
                    \"build_log\": $BUILD_LOG,
                    \"sonar_errors\": $SONAR_ERRORS
                }" > $PAYLOAD_FILE
            else
              BUILD_RESULT="ok"
              echo "{
                    \"run_number\": $RUN_NUMBER,
                    \"build_result\": \"$BUILD_RESULT\",
                    \"commit\": \"$COMMIT\",
                    \"workflow_url\": \"https://github.com/$REPO/actions/runs/$RUN_ID\",
                    \"sonar_errors\": $SONAR_ERRORS
                }" > $PAYLOAD_FILE
            fi
        
      - name: Subir JSON al repo
        run: |
              git config --global user.email "bot@example.com"
              git config --global user.name "CI Bot"
              git add salida/resultado.json
              git add -A postman           # <-- agrega la carpeta completa
              git status
              git commit -m "ci: resultado de análisis" || echo "Sin cambios para commitear"
              git push

