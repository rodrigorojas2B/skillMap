name: Generar funcionalidad desde historia de usuario

on:
  push:
    paths:
      - 'historias-usuario/**.yml'

jobs:
  generar_codigo:
    runs-on: ubuntu-latest

    steps:
      - name: Clonar repositorio actual
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_PAT }}
          path: repositorio-base

      - name: Detectar historia de usuario modificada
        id: historia
        run: |
          cd repositorio-base
          git fetch --unshallow || true
          base_sha="${{ github.event.before }}"
          if ! git cat-file -e "$base_sha"^{commit} 2>/dev/null; then
            echo "‚ö†Ô∏è SHA base no v√°lido o sin historial, usando HEAD^"
            base_sha="HEAD^"
          fi
          echo "üîç Comparando con base: $base_sha"
          archivo=$(git diff --name-only "$base_sha" HEAD | grep '^historias-usuario/.*\.yml$' | head -n 1 || true)
          if [ -z "$archivo" ]; then
            echo "‚õî No se encontr√≥ ninguna historia de usuario modificada. Abortando."
            exit 1
          fi
          echo "ruta=$archivo" >> "$GITHUB_OUTPUT"

      - name: Leer contenido de historia de usuario
        run: |
          cd repositorio-base
          cat "${{ steps.historia.outputs.ruta }}" > entrada_gpt.txt

      - name: Instalar dependencias necesarias
        run: |
          sudo apt-get update
          sudo apt-get install -y jq unzip openjdk-17-jdk maven

      - name: Limpieza previa de clases generadas (si existen)
        run: |
          cd repositorio-base
          echo "üßπ Eliminando clases generadas residuales..."
          rm -rf src/main/java/ai/generated
          rm -rf src/test/java/ai/generated
        

      - name: Indexar y agregar contenido de clases Java existentes al prompt
        run: |
          cd repositorio-base
      
          echo "üìÅ Buscando clases Java..."
          find src/main/java -type f -name "*.java" > clases_existentes.txt
      
          if [ ! -s clases_existentes.txt ]; then
            echo "‚ùå No se encontraron archivos .java. Abortando."
            exit 1
          fi
      
          echo "üì¶ Clases detectadas:"
          cat clases_existentes.txt
      
          echo -e "\n\n--- HISTORIA DE USUARIO ---" > entrada_gpt.txt
          cat "${{ steps.historia.outputs.ruta }}" >> entrada_gpt.txt
      
          echo -e "\n\n--- CLASES DISPONIBLES EN EL PROYECTO ---" >> entrada_gpt.txt
          cat clases_existentes.txt | sed 's|.*/||' | sed 's|\.java||' >> entrada_gpt.txt
      
          echo -e "\n\n--- C√ìDIGO EXISTENTE DEL PROYECTO ---" >> entrada_gpt.txt
      
          while read -r clase; do
            echo -e "\n\n// Archivo: $clase\n" >> entrada_gpt.txt
      
            if grep -q '// Other methods' "$clase"; then
              echo "‚õî El archivo $clase contiene '// Other methods...'. Reempl√°zalo por el c√≥digo real antes de continuar."
              exit 1
            fi
      
            cat "$clase" >> entrada_gpt.txt
          done < clases_existentes.txt
      
          cat <<'EOF' >> entrada_gpt.txt
      
          --- AN√ÅLISIS DE CLASES EXISTENTES ---
          Genera una tabla Markdown como esta:
      
          | Clase Java | Package | Clasificaci√≥n | Motivo |
          |------------|---------|----------------|--------|
          | Employee | com.example.EmployeeCoreApi.model | REUTILIZABLE-AS-IS | Contiene atributo `gender` |
          | EmployeeServiceImpl | com.example.EmployeeCoreApi.service.impl | MODIFICABLE | Debe validar antes de borrar |
          | CannotDeleteEmployeeException | com.example.EmployeeCoreApi.exception | NUEVA | Requerida para lanzar excepci√≥n |
          | EmployeeServiceImplTest | com.example.EmployeeCoreApi.service.impl | NUEVA | Pruebas unitarias de validaci√≥n |
      
          --- INSTRUCCIONES DE MODIFICACI√ìN ---
          - No eliminar ni reemplazar l√≥gica existente.
          - Si se modifica un m√©todo, incluirlo completo con el nuevo c√≥digo y lo que ya ten√≠a.
          - Solo generar clases nuevas si est√°n indicadas como NUEVA.
          - Cada clase debe estar en su package correcto, seg√∫n lo indicado en la tabla.
          - NO repetir clases ya existentes si no cambian.
          - NO eliminar los m√©todos existentes a menos que sea necesario
          - NO reemplazar m√©todos u otro contenido de las clases existentes por comentarios entre l√≠neas
          - Solo considerar como existente una clase si est√° listada expl√≠citamente en "CLASES DISPONIBLES EN EL PROYECTO".
          - No debes asumir la existencia de clases que no aparecen expl√≠citamente en la secci√≥n anterior. Si alguna clase no est√° listada entre las clases disponibles ni aparece en el c√≥digo entregado, debe considerarse INEXISTENTE y marcada como NUEVA en el an√°lisis.
          - Si una clase no aparece listada, asumir que es NUEVA.
          - Si una clase herada de otra clase o importa una interfaz propia del proyecto aseg√∫rate que esta est√© entre las clases existentes o genera el c√≥digo respectivo de no existir previamente
      
          --- C√ìDIGO A GENERAR ---
          Devuelve solo clases Java v√°lidas. Cada bloque debe comenzar con `package ...`.
          Incluye los tests JUnit5 en el mismo formato si aplica.
          EOF
      

      - name: Llamar a OpenAI para diagn√≥stico (solo an√°lisis y clasificaci√≥n)
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          cd repositorio-base

          jq -Rs --arg SYSTEM_MSG "Eres un analista de clases Java que trabaja exclusivamente con los archivos entregados a continuaci√≥n. No supongas la existencia de clases que no se proporcionan. Si una clase no aparece expl√≠citamente, debe asumirse como no existente. No devuelvas c√≥digo a√∫n, solo an√°lisis y tabla." '{
            model: "gpt-4",
            messages: [
              { "role": "system", "content": $SYSTEM_MSG },
              { "role": "user", "content": . }
            ],
            temperature: 0.2
          }' entrada_gpt.txt > payload_diagnostico.json

          curl -s https://api.openai.com/v1/chat/completions \
            -H "Authorization: Bearer $OPENAI_API_KEY" \
            -H "Content-Type: application/json" \
            -d @payload_diagnostico.json > respuesta_gpt_diagnostico.json

          echo "üì® Respuesta de OpenAI:"
          cat respuesta_gpt_diagnostico.json

          jq -r '.choices[0].message.content // "‚ùå GPT no devolvi√≥ contenido v√°lido."' respuesta_gpt_diagnostico.json > diagnostico_gpt.txt

      - name: Mostrar an√°lisis GPT
        run: |
          echo "üìã Tabla de diagn√≥stico de clases:"
          if [ -s repositorio-base/diagnostico_gpt.txt ]; then
            cat repositorio-base/diagnostico_gpt.txt
          else
            echo "‚ö†Ô∏è El archivo de diagn√≥stico no se gener√≥ o est√° vac√≠o."
            echo "üìÇ Contenido de repositorio-base:"
            ls -l repositorio-base/
          fi
        
      - name: Preparar entrada para generaci√≥n de c√≥digo
        run: |
          cd repositorio-base

          echo "--- HISTORIA DE USUARIO ---" > entrada_final_gpt.txt
          cat "${{ steps.historia.outputs.ruta }}" >> entrada_final_gpt.txt

          echo -e "\n\n--- DIAGN√ìSTICO Y PLAN DE CLASES ---" >> entrada_final_gpt.txt
          cat diagnostico_gpt.txt >> entrada_final_gpt.txt

          cat <<'EOF' >> entrada_final_gpt.txt

          --- INSTRUCCIONES DE GENERACI√ìN DE C√ìDIGO ---
          - Modifica √∫nicamente las clases marcadas como MODIFICABLE.
          - Crea nuevas clases solo si est√°n indicadas como NUEVA.
          - No cambies de paquete ni nombre de clase.
          - Si modificas un m√©todo, incl√∫yelo completo con su l√≥gica anterior m√°s la nueva.
          - No omitas l√≥gica existente.
          - Cada clase debe comenzar con `package ...`.
          - Devuelve √∫nicamente clases y tests JUnit 5 v√°lidos.
          - No incluyas explicaciones ni comentarios adicionales.
          - Si una clase existente implementa una interfaz, o hereda de otra clase, debes mantener esa declaraci√≥n `implements o extends ...`.
          - No elimines implementaciones de interfaces ya declaradas.
          - La firma de las clases y m√©todos debe mantenerse sin cambio a menos que la nueva funcionalidad lo requiera
          - Si se crea una llamada a un m√©todo de la clase modificada aseg√∫rate que ese m√©todo exista en la clase
          - Si se crea una llamada a un m√©todo de otra clase aseg√∫rate que ese m√©todo exista en la clase o cr√©alo de ser necesario
          - Asegurate que el el c√≥digo generado sea compilable, corr√≠jelo hasta que lo sea
          - Nunca uses el m√©todo stream() u otros m√©todos que pueden ser ambiguos entre versiones de Java.
          - Siempre importa las clases que uses dentro de otra clase, valida siempre que clase clase utilizada tenga su import correspondiente.
          - Cuando asignes el resultado de un m√©todo a una variable siempre los tipos de la variable y el m√©todo deben ser compatibles.  Por ejemplo, no trates de asignar un m√©todo que retorna Iterable a una variable de tipo List.
          EOF


      - name: Llamar a OpenAI para generaci√≥n de c√≥digo
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          cd repositorio-base

          # Guardamos el contenido del prompt como variable segura
          PROMPT=$(cat entrada_final_gpt.txt | jq -Rs .)

          # Creamos el JSON de payload
          cat <<EOF > payload_generacion.json
          {
            "model": "gpt-4",
            "messages": [
              {
                "role": "system",
                "content": "Eres un generador de c√≥digo Java experto en Spring Boot. Tu salida debe contener √∫nicamente c√≥digo fuente Java completamente v√°lido. Cada clase debe comenzar con 'package ...' y contener la declaraci√≥n completa de la clase (public class, interface o enum). No debes escribir ning√∫n texto explicativo, encabezado, numeraci√≥n, ni comentarios como '1.', '2.', 'Test Unitario:', etc. Si la clase ya existe en el repositorio, debes conservar su package original y todos sus m√©todos, incluso si no se modifican. No puedes inventar nuevos packages como 'com.example.demo'. Si una clase es nueva, debe estar marcada como NUEVA en el an√°lisis previo. No escribas ning√∫n contenido fuera de los bloques de c√≥digo. El resultado debe ser compilable sin errores ni contenido basura."
              },
              {
                "role": "user",
                "content": $PROMPT
              }
            ],
            "temperature": 0.3
          }
          EOF

          echo "üßæ Payload generado para OpenAI:"
          cat payload_generacion.json

          curl -s https://api.openai.com/v1/chat/completions \
            -H "Authorization: Bearer $OPENAI_API_KEY" \
            -H "Content-Type: application/json" \
            -d @payload_generacion.json > respuesta_gpt.json

          echo "üì® Respuesta de OpenAI:"
          cat respuesta_gpt.json

          jq -r '.choices[0].message.content // "‚ùå GPT no devolvi√≥ contenido v√°lido."' respuesta_gpt.json \
          | sed '/^```/d' \
          > clases_generadas.java

          echo "üìÑ C√≥digo generado completo por GPT antes de limpieza:"
          echo "--------------------------------------------------------"
          cat clases_generadas.java
          echo "--------------------------------------------------------"

      - name: Limpiar y separar clases generadas
        run: |
          cd repositorio-base
      
          echo "üßπ Limpiando residuos de formato GPT..."
          sed -i '/^---/d' clases_generadas.java
          sed -i '/^```/d' clases_generadas.java
          sed -i '/^# .*$/d' clases_generadas.java
          sed -i '/^\/\/ Clase de prueba:/d' clases_generadas.java
          sed -i '/^\/\/ Clase modificada:/d' clases_generadas.java
          sed -i '/^\/\/ Resto de los m√©todos existentes\.\.\./d' clases_generadas.java
          sed -i '/^--- CLASE MODIFICADA ---/d' clases_generadas.java
          sed -i '/^[0-9]\+\.\s\+Clase/d' clases_generadas.java
          sed -i '/^[0-9]\+\.\s\+Pruebas/d' clases_generadas.java
          sed -i '/^.*Clase.*nueva.*$/d' clases_generadas.java
          sed -i '/^.*Pruebas.*$/d' clases_generadas.java
          sed -i '/^$/d' clases_generadas.java
      
          echo "üìù Mostrando contenido final antes de separar:"
          cat clases_generadas.java
      
          echo "üßΩ Ajustando para que el primer package sea la primera l√≠nea √∫til..."
          awk 'BEGIN{found=0} /^\s*package /{found=1} found' clases_generadas.java > clases_generadas_limpio.java
          mv clases_generadas_limpio.java clases_generadas.java
      
          echo "üìÇ Separando clases en archivos individuales..."
          mkdir -p src/main/java/ai/generated
          mkdir -p src/test/java/ai/generated
          csplit --quiet --prefix=clase_ --suffix-format=%02d.java clases_generadas.java "/^package /" {*}
      
          echo "üìÇ Procesando archivos clase_*.java..."
          echo "üóÇÔ∏è Archivos generados antes de moverlos:"
          ls -l clase_*.java
      
          for file in clase_*.java; do
            echo "üîç Analizando archivo: $file"
            echo "üîç Contenido de $file:"
            cat "$file"
      
            # Validar que contiene declaraci√≥n de paquete v√°lida
            if ! grep -qE '^\s*package\s+[a-zA-Z0-9_.]+;' "$file"; then
              echo "‚ö†Ô∏è Archivo $file no contiene declaraci√≥n de paquete v√°lida. Eliminando."
              rm "$file"
              continue
            fi
      
            # Validar que contiene clase, interfaz o enum
            if ! grep -qE '\b(class|interface|enum)\b' "$file"; then
              echo "‚ö†Ô∏è Archivo $file no contiene clase, interfaz ni enum. Eliminando."
              rm "$file"
              continue
            fi
      
            class_name=$(grep -oP 'public\s+(class|interface|enum)\s+\K\w+' "$file" | head -n 1)
            if [ -z "$class_name" ]; then
              echo "‚ö†Ô∏è No se pudo determinar el nombre de clase en $file. Eliminando."
              rm "$file"
              continue
            fi
      
            if grep -q '@Test' "$file"; then
              dest="src/test/java/ai/generated"
              echo "‚úÖ Clasificado como TEST -> $dest/${class_name}.java"
            else
              dest="src/main/java/ai/generated"
              echo "‚úÖ Clasificado como CLASE -> $dest/${class_name}.java"
            fi
      
            mv "$file" "$dest/${class_name}.java"
          done
      

      - name: Fusionar clases generadas con las originales (si existen)
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          cd repositorio-base

          echo "üß† Fusionando clases generadas con originales (si aplica)"

          for generada in src/main/java/ai/generated/*.java; do
            class_name=$(basename "$generada")

            original_path=$(find src/main/java -type f -name "$class_name" | grep -v /ai/generated/ | head -n 1 || true)

            if [ -z "$original_path" ]; then
              echo "üîπ $class_name es clase nueva. No se fusiona."
              continue
            fi

            echo "üîÑ Fusionando $class_name"

            FUSION_PROMPT=$'--- CLASE ORIGINAL EXISTENTE ---\n'
            FUSION_PROMPT+="$(cat "$original_path")"
            FUSION_PROMPT+=$'\n\n--- CLASE GENERADA POR IA ---\n'
            FUSION_PROMPT+="$(cat "$generada")"
            FUSION_PROMPT+=$'\n\n--- INSTRUCCIONES ---\n'
            FUSION_PROMPT+="Fusiona ambas clases asegurando lo siguiente:\n"
            FUSION_PROMPT+="- Mant√©n todos los m√©todos v√°lidos de la clase original.\n"
            FUSION_PROMPT+="- Agrega los m√©todos nuevos de la clase generada.\n"
            FUSION_PROMPT+="- Reemplaza m√©todos si tienen la misma firma pero diferente cuerpo.\n"
            FUSION_PROMPT+="- No elimines m√©todos v√°lidos del original que no est√©n en la nueva.\n"
            FUSION_PROMPT+="- Devuelve solo una clase Java v√°lida (sin explicaciones, sin texto extra, sin backticks)."

            jq -n --arg fusion "$FUSION_PROMPT" ' {
              model: "gpt-4",
              messages: [
                { "role": "system", "content": "Eres un generador de c√≥digo Java. Fusiona y devuelve solo una clase final completa y corregida." },
                { "role": "user", "content": $fusion }
              ],
              temperature: 0.3
            }' > payload_fusion_clase.json

            curl -s https://api.openai.com/v1/chat/completions \
              -H "Authorization: Bearer $OPENAI_API_KEY" \
              -H "Content-Type: application/json" \
              -d @payload_fusion_clase.json > respuesta_fusion_clase.json

            jq -r '.choices[0].message.content // "‚ùå Sin contenido v√°lido."' respuesta_fusion_clase.json \
              | sed '/^```/d' > "$original_path"

            echo "‚úÖ Clase fusionada: $original_path"
          done
  

      - name: Reemplazar clases generadas en ubicaci√≥n original
        run: |
          cd repositorio-base

          echo "üì¶ Detectando package y ubicaci√≥n de cada clase..."

          for file in src/main/java/ai/generated/*.java src/test/java/ai/generated/*.java; do
            [ -e "$file" ] || continue

            package_line=$(grep '^package ' "$file" | head -n 1)
            package_path=$(echo "$package_line" | sed -E 's/package ([a-zA-Z0-9_.]+);/\1/' | tr '.' '/')
            class_name=$(basename "$file")

            if [[ "$file" == *test* ]]; then
              dest="src/test/java/$package_path"
            else
              dest="src/main/java/$package_path"
            fi

            mkdir -p "$dest"
            mv "$file" "$dest/$class_name"
            echo "‚úÖ Movido: $file -> $dest/$class_name"
          done

      - name: Correcci√≥n de errores de compilaci√≥n (m√°x 3 intentos)
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          cd repositorio-base
      
          intentos=0
          exito=0
      
          while [ $intentos -lt 3 ]; do
            echo "üîÅ Intento de compilaci√≥n #$((intentos+1))"
            echo "üì¶ C√≥digo compilado:"
            find src/main/java -name '*.java' -exec echo "---- {} ----" \; -exec cat {} \;
      
            if mvn compile; then
              echo "‚úÖ Compilaci√≥n exitosa"
              exito=1
              break
            fi
      
            echo "‚ùå Fall√≥ la compilaci√≥n. Capturando errores..."
            mvn compile > error_build.log 2>&1 || true
      
            echo "üß† An√°lisis de error con GPT (Diagn√≥stico avanzado)..."
      
            DIAG_CONTENT=$'--- LOG DE COMPILACI√ìN FALLIDA ---\n'
            DIAG_CONTENT+="$(cat error_build.log)"
      
            DIAG_CONTENT+=$'\n\n--- CONTEXTO DE CLASES DISPONIBLES ---\n'
            for file in $(find src/main/java -name "*.java"); do
              if grep -qE "public\s+(class|interface|enum)" "$file"; then
                DIAG_CONTENT+=$'\n\n--- ARCHIVO: '"$file"$' ---\n'
                DIAG_CONTENT+="$(head -n 80 "$file")"
              fi
            done
      
            DIAG_CONTENT+=$'\n\n--- INSTRUCCIONES ---\n'
            DIAG_CONTENT+="Eres un experto compilador de Java. Analiza el log y el c√≥digo entregado.\n"
            DIAG_CONTENT+="Entrega un plan de correcci√≥n claro y estructurado.\n"
            DIAG_CONTENT+="Por cada error, indica: archivo, l√≠nea estimada, explicaci√≥n y clases relacionadas.\n"
            DIAG_CONTENT+="No entregues c√≥digo fuente. Solo un plan detallado.\n"
      
            jq -n \
              --arg diag "$DIAG_CONTENT" \
              '{
                model: "gpt-4",
                messages: [
                  {
                    "role": "system",
                    "content": "Eres un compilador experto en Java. Entrega un plan de correcci√≥n detallado a partir del log y clases provistas."
                  },
                  {
                    "role": "user",
                    "content": $diag
                  }
                ],
                temperature: 0.2
              }' > payload_diagnostico_errores.json
      
            curl -s https://api.openai.com/v1/chat/completions \
              -H "Authorization: Bearer $OPENAI_API_KEY" \
              -H "Content-Type: application/json" \
              -d @payload_diagnostico_errores.json > respuesta_diagnostico.json
      
            PLAN_CORRECCION=$(jq -r '.choices[0].message.content' respuesta_diagnostico.json)
            echo "üìã Plan de correcci√≥n recibido:"
            echo "$PLAN_CORRECCION"
      
            echo "üß† Generando c√≥digo corregido con GPT..."
      
            CODIGO_CONTENT=$'--- PLAN DE CORRECCI√ìN ---\n'
            CODIGO_CONTENT+="$PLAN_CORRECCION"
      
            CODIGO_CONTENT+=$'\n\n--- C√ìDIGO ACTUAL CON ERROR ---\n'
            for file in $(find src/main/java -name "*.java"); do
              if grep -qE "public\s+(class|interface|enum)" "$file"; then
                CODIGO_CONTENT+=$'\n\n--- ARCHIVO: '"$file"$' ---\n'
                CODIGO_CONTENT+="$(cat "$file")"
              fi
            done
      
            CODIGO_CONTENT+=$'\n\n--- INSTRUCCIONES ---\n'
            CODIGO_CONTENT+="Corrige el c√≥digo seg√∫n el plan. Devuelve solo clases completas y compilables.\n"
            CODIGO_CONTENT+="‚úÖ REGLAS:\n"
            CODIGO_CONTENT+="1. Modifica exclusivamente las clases indicadas.\n"
            CODIGO_CONTENT+="2. No elimines atributos ni m√©todos existentes, salvo que est√© indicado.\n"
            CODIGO_CONTENT+="3. Cada clase debe comenzar con 'package ...' y tener imports v√°lidos.\n"
            CODIGO_CONTENT+="4. No entregues comentarios, explicaciones, ni bloques Markdown.\n"
            CODIGO_CONTENT+="5. Devuelve √∫nicamente el c√≥digo fuente v√°lido, sin encabezados.\n"
      
            jq -n \
              --arg corr "$CODIGO_CONTENT" \
              '{
                model: "gpt-4",
                messages: [
                  {
                    "role": "system",
                    "content": "Eres un generador de c√≥digo Java. Devuelve solo clases completas y compilables."
                  },
                  {
                    "role": "user",
                    "content": $corr
                  }
                ],
                temperature: 0.3
              }' > payload_codigo_corregido.json
      
            curl -s https://api.openai.com/v1/chat/completions \
              -H "Authorization: Bearer $OPENAI_API_KEY" \
              -H "Content-Type: application/json" \
              -d @payload_codigo_corregido.json > respuesta_codigo.json
      
            jq -r '.choices[0].message.content // ""' respuesta_codigo.json \
              > clases_generadas.java
      
            echo "üìÑ C√≥digo generado:"
            cat clases_generadas.java
      
            echo "üßπ Limpiando residuos de formato GPT..."
            sed -i '/^---/d' clases_generadas.java
            sed -i '/^```/d' clases_generadas.java
            sed -i '/^# .*$/d' clases_generadas.java
            sed -i '/^\/\/ Clase de prueba:/d' clases_generadas.java
            sed -i '/^\/\/ Clase modificada:/d' clases_generadas.java
            sed -i '/^\/\/ Resto de los m√©todos existentes\.\.\./d' clases_generadas.java
            sed -i '/^--- CLASE MODIFICADA ---/d' clases_generadas.java
            sed -i '/^--- ARCHIVO:/d' clases_generadas.java
            sed -i '/^[0-9]\+\.\s\+Clase/d' clases_generadas.java
            sed -i '/^[0-9]\+\.\s\+Pruebas/d' clases_generadas.java
            sed -i '/^.*Clase.*nueva.*$/d' clases_generadas.java
            sed -i '/^.*Pruebas.*$/d' clases_generadas.java
            sed -i '/^\s*$/d' clases_generadas.java
      
            echo "üßΩ Ajustando para que el primer package sea la primera l√≠nea √∫til..."
            awk 'BEGIN{found=0} /^\s*package /{found=1} found' clases_generadas.java > clases_generadas_limpio.java
            mv clases_generadas_limpio.java clases_generadas.java

            echo "üßπ Limpiando residuos de formato GPT..."
            sed -i '/^---/d' clases_generadas.java
            sed -i '/^```/d' clases_generadas.java
            sed -i '/^# .*$/d' clases_generadas.java
            sed -i '/^\/\/ Clase de prueba:/d' clases_generadas.java
            sed -i '/^\/\/ Clase modificada:/d' clases_generadas.java
            sed -i '/^\/\/ Resto de los m√©todos existentes\.{3}/d' clases_generadas.java
            sed -i '/^--- CLASE MODIFICADA ---/d' clases_generadas.java
            sed -i '/^--- ARCHIVO:/d' clases_generadas.java
            sed -i '/^[0-9]+\.\s+Clase/d' clases_generadas.java
            sed -i '/^[0-9]+\.\s+Pruebas/d' clases_generadas.java
            sed -i '/^.*Clase.*nueva.*$/d' clases_generadas.java
            sed -i '/^.*Pruebas.*$/d' clases_generadas.java
            sed -i '/\b(Esta clase|Este m√©todo|En este c√≥digo|En esta clase|Ahora|Se ha modificado)\b/d' clases_generadas.java
            sed -i '/\b(Esto|Este cambio|Por lo tanto|Finalmente|Luego|Entonces)\b.*\./d' clases_generadas.java
            sed -i '/^[[:space:]]*$/d' clases_generadas.java
            sed -i '/^\s*$/d' clases_generadas.java

            echo "üßΩ Ajustando para que el primer package sea la primera l√≠nea √∫til..."
            awk 'BEGIN{found=0} /^\s*package /{found=1} found' clases_generadas.java > clases_generadas_limpio.java
            mv clases_generadas_limpio.java clases_generadas.java

      
            echo "üìÇ Separando clases en archivos individuales..."
            rm -f clase_*.java
            csplit --quiet --prefix=clase_ --suffix-format=%02d.java clases_generadas.java "/^package /" {*}
      
            for file in clase_*.java; do
              if ! grep -qE 'package\s+[a-zA-Z0-9_.]+;' "$file"; then rm "$file"; continue; fi
              if ! grep -qE '\b(class|interface|enum)\b' "$file"; then rm "$file"; continue; fi
              pkg=$(grep -oP '^package\s+\K[\w.]+' "$file")
              path="src/main/java/$(echo $pkg | tr '.' '/')"
              mkdir -p "$path"
              class_name=$(grep -oP 'public\s+(class|interface|enum)\s+\K\w+' "$file" | head -n 1)
              mv "$file" "$path/$class_name.java"
            done
      
            intentos=$((intentos+1))
          done
      
          if [ $exito -eq 0 ]; then
            echo "‚ùå Se alcanz√≥ el m√°ximo de intentos sin √©xito"
            exit 1
          fi
          
      
      - name: An√°lisis original con SonarCloud
        if: success()  # Solo si la compilaci√≥n fue exitosa
        working-directory: repositorio-base
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        run: |
          mvn sonar:sonar \
            -Dsonar.projectKey=rodrigorojasg_testSpring \
            -Dsonar.organization=rodrigorojasg \
            -Dsonar.projectName="testSpring Original" \
            -Dsonar.sources=src/main/java \
            -Dsonar.tests=src/test \
            -Dsonar.java.binaries=target/classes \
            -Dsonar.host.url=https://sonarcloud.io \
            -Dsonar.login=$SONAR_TOKEN
      
      - name: Guardar reporte original
        working-directory: repositorio-base
        if: success()
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        run: |
          echo "üóÉÔ∏è Obteniendo reporte de issues desde SonarCloud..."
          curl -s "https://sonarcloud.io/api/issues/search?componentKeys=rodrigorojasg_testSpring&resolved=false" \
            -H "Authorization: Bearer $SONAR_TOKEN" > reporte_original.json
      
      - name: Detectar archivos con errores
        if: success()
        run: |
          echo "üîç Detectando archivos afectados..."
          jq -r '.issues[].component' reporte_original.json | sort -u > archivos_afectados.txt
          echo "üìÑ Archivos con problemas:"
          cat archivos_afectados.txt
          mkdir -p repositorio-base
          mv archivos_afectados.txt repositorio-base/
          

      - name: Llamar a OpenAI por cada archivo afectado
        working-directory: repositorio-base
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        run: |
          iter=1
          echo "ITERACION_ACTUAL=$iter" >> $GITHUB_ENV
          mkdir -p reportes_ci errores_ci

          while read COMPONENT; do
            echo "üìÑ Analizando componente: $COMPONENT"
            FILE=$(echo "$COMPONENT" | sed 's/^rodrigorojasg_testSpring://')

            if [ ! -f "$FILE" ]; then
              echo "‚ö†Ô∏è Archivo no encontrado: $FILE"
              continue
            fi

            BASENAME=$(basename "$FILE" .java)
            if [ -z "$BASENAME" ]; then
              echo "‚ùå Nombre de archivo inv√°lido (basename vac√≠o). FILE: $FILE"
              continue
            fi

            CODE_B64=$(base64 "$FILE" | tr -d '\n')

            REPORT=$(curl -s "https://sonarcloud.io/api/issues/search?componentKeys=$COMPONENT&resolved=false" \
              -H "Authorization: Bearer $SONAR_TOKEN" |
              jq -r '.issues[] | "\(.severity): \(.message) (line \(.line))"' | tr '\n' ' ')

            if [ -z "$REPORT" ]; then
              echo "‚ö†Ô∏è No se encontraron problemas espec√≠ficos en $FILE, se omite"
              continue
            fi

            RESPONSE_FILE="reportes_ci/gpt_response_${BASENAME}.json"

            PROMPT_SISTEMA="Eres un asistente experto en Java y Spring Boot. Vas a recibir una clase en Java codificada en base64 y una lista de problemas de calidad detectados por SonarCloud. Tu tarea es corregir solo esos problemas, manteniendo la l√≥gica y estructura original."

            MENSAJE_USUARIO="Este es el c√≥digo fuente en base64: $CODE_B64. A continuaci√≥n, los problemas reportados por SonarCloud: $REPORT.

            Corrige exclusivamente esos problemas. ‚ö†Ô∏è IMPORTANTE: responde √öNICAMENTE con el contenido completo de la clase Java ya corregida, como texto plano, sin ning√∫n tipo de formato Markdown, sin backticks (\`\`\`), sin encabezados, sin frases introductorias, sin comentarios adicionales ni explicaciones.

            Devuelve solo el archivo .java ya corregido, como si estuvieras sobrescribiendo el original. No incluyas nada m√°s."

            jq -n \
              --arg prompt "$PROMPT_SISTEMA" \
              --arg user "$MENSAJE_USUARIO" \
              '{
                model: "gpt-4",
                messages: [
                  { role: "system", content: $prompt },
                  { role: "user", content: $user }
                ],
                temperature: 0.3
              }' > payload.json

            curl -s https://api.openai.com/v1/chat/completions \
              -H "Authorization: Bearer $OPENAI_API_KEY" \
              -H "Content-Type: application/json" \
              -d @payload.json > "$RESPONSE_FILE"

            RESPUESTA=$(jq -r '.choices[0].message.content // empty' "$RESPONSE_FILE")

            DESTINO_MEJORADO="src/${FILE#src/}"
            DESTINO_MEJORADO="${DESTINO_MEJORADO%.java}.mejorado.java"
            mkdir -p "$(dirname "$DESTINO_MEJORADO")"

            echo "üîç Contenido recibido de GPT para $FILE:"
            echo "$RESPUESTA"
            echo "----------------------------------------"

            if echo "$RESPUESTA" | grep -q "public class"; then
              echo "$RESPUESTA" > "$DESTINO_MEJORADO"
              echo "‚úÖ Generado: $DESTINO_MEJORADO"
            else
              echo "$RESPUESTA" > "errores_ci/${BASENAME}.error.txt"
              echo "‚ùå Contenido inesperado para $FILE, guardado en errores_ci"
            fi
          done < archivos_afectados.txt




      - name: Preparar carpeta src-analizado
        run: |
          mkdir -p src-analizado/main/java
          for f in $(find . -name "*.mejorado.java"); do
            destino="src-analizado/$(echo $f | cut -d/ -f2- | sed 's/\.mejorado//')"
            mkdir -p $(dirname "$destino")
            cp "$f" "$destino"
          done

      - name: Preparar carpeta para an√°lisis Sonar del c√≥digo mejorado
        working-directory: repositorio-base
        run: |
          echo "üì¶ Preparando archivos mejorados para Sonar..."
          mkdir -p src-analizado/main/java
          find src/main/java -name '*.mejorado.java' | while read file; do
            relpath="${file#src/main/java/}"
            destino="src-analizado/main/java/${relpath%.mejorado.java}.java"
            mkdir -p "$(dirname "$destino")"
            cp "$file" "$destino"
            echo "‚úÖ Copiado: $file -> $destino"
          done

      - name: Verificar archivos mejorados
        working-directory: repositorio-base
        run: |
          echo "üìÅ Verificando contenido de src-analizado/main/java:"
          if [ -d src-analizado/main/java ]; then
            find src-analizado/main/java -type f
          else
            echo "‚õî La carpeta src-analizado/main/java no existe. Deteniendo ejecuci√≥n."
            exit 1
          fi


      - name: An√°lisis con SonarCloud del c√≥digo mejorado
        working-directory: repositorio-base
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        run: |
          if [ ! -d src-analizado/main/java ]; then
            echo "‚õî Carpeta src-analizado/main/java no existe. Saltando an√°lisis Sonar."
            exit 0
          fi
      
          mvn sonar:sonar \
            -Dsonar.projectKey=rodrigorojasg_testSpring_gpt \
            -Dsonar.organization=rodrigorojasg \
            -Dsonar.projectName="testSpring GPT Mejorado" \
            -Dsonar.sources=src-analizado/main/java \
            -Dsonar.tests=src/test \
            -Dsonar.java.binaries=target/classes \
            -Dsonar.host.url=https://sonarcloud.io \
            -Dsonar.login=$SONAR_TOKEN
        

      - name: Mostrar respuesta cruda del an√°lisis mejorado
        working-directory: repositorio-base
        run: |
          echo "üõ†Ô∏è Guardando respuesta de SonarCloud (c√≥digo mejorado)..."
          curl -s "https://sonarcloud.io/api/issues/search?componentKeys=rodrigorojasg_testSpring_gpt&resolved=false" \
            -H "Authorization: Bearer $SONAR_TOKEN" > reporte_mejorado.json
      
          echo "üìÇ Contenido del reporte:"
          cat reporte_mejorado.json
          

      - name: Comparar resultados de an√°lisis
        working-directory: repositorio-base
        id: comparar_errores
        run: |
          echo "üìä Comparaci√≥n de severidades:"

          echo "ANTES:"
          jq '[.issues[]?.severity] | group_by(.) | map({ (.[0]): length }) | add' reporte_original.json > severidades_antes.json
          cat severidades_antes.json

          echo "DESPU√âS:"
          if [ "$(jq -r '.issues | length' reporte_mejorado.json)" -eq 0 ]; then
            echo "No hay errores reportados" > severidades_despues.json
            cat severidades_despues.json
          else
            jq '[.issues[]?.severity] | group_by(.) | map({ (.[0]): length }) | add' reporte_mejorado.json > severidades_despues.json
            cat severidades_despues.json
          fi

          puntaje_antes=$(jq '[.issues[]?.severity] |
            map(
              if . == "BLOCKER" then 10
              elif . == "CRITICAL" then 7
              elif . == "MAJOR" then 5
              elif . == "MINOR" then 3
              elif . == "INFO" then 1
              else 0 end
            ) | add // 0' reporte_original.json)

          puntaje_despues=$(jq '[.issues[]?.severity] |
            map(
              if . == "BLOCKER" then 10
              elif . == "CRITICAL" then 7
              elif . == "MAJOR" then 5
              elif . == "MINOR" then 3
              elif . == "INFO" then 1
              else 0 end
            ) | add // 0' reporte_mejorado.json)

          echo "PUNTAJE_ANTES=$puntaje_antes" >> $GITHUB_ENV
          echo "PUNTAJE_DESPUES=$puntaje_despues" >> $GITHUB_ENV

          if [ "$puntaje_despues" -lt "$puntaje_antes" ]; then
            echo "MEJORA_SIGNIFICATIVA=true" >> $GITHUB_ENV
            echo "‚úÖ Mejora significativa detectada (‚Üì $puntaje_antes ‚Üí $puntaje_despues)"
          elif [ "$puntaje_despues" -eq "$puntaje_antes" ]; then
            echo "MEJORA_SIGNIFICATIVA=false" >> $GITHUB_ENV
            echo "‚ö†Ô∏è Sin cambios en severidades ($puntaje_antes ‚Üí $puntaje_despues)"
          else
            echo "MEJORA_SIGNIFICATIVA=false" >> $GITHUB_ENV
            echo "‚õî Las severidades aumentaron ($puntaje_antes ‚Üí $puntaje_despues)"
          fi
    
      - name: üß† Generar colecci√≥n Postman desde c√≥digo Java (inline)
        run: |
          echo "üîç Buscando controladores Java..."
          mkdir -p repositorio-base/postman
          echo '{
            "info": {
              "name": "Colecci√≥n Generada",
              "schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json"
            },
            "item": [' > repositorio-base/postman/coleccion-generada.json
      
          first=true
          find repositorio-base/src/main/java -name '*Controller.java' | while read file; do
            ruta_base=$(grep '@RequestMapping' "$file" | sed -n 's/.*"\(.*\)".*/\1/p')
            grep -E '@(Get|Post|Put|Delete)Mapping' "$file" | while read linea; do
              metodo=$(echo "$linea" | grep -oE '@[A-Za-z]+Mapping' | sed 's/@//;s/Mapping//')
              subruta=$(echo "$linea" | sed -n 's/.*("\(.*\)").*/\1/p')
              funcion=$(grep -A1 "$linea" "$file" | tail -n1 | sed -n 's/.* \([a-zA-Z0-9_]\+\)(.*/\1/p')
              fullruta="${ruta_base}${subruta}"
              [ "$first" = false ] && echo "," >> repositorio-base/postman/coleccion-generada.json
              first=false
              echo "    {
                \"name\": \"$funcion\",
                \"request\": {
                  \"method\": \"${metodo^^}\",
                  \"header\": [],
                  \"url\": {
                    \"raw\": \"http://localhost:8080$fullruta\",
                    \"protocol\": \"http\",
                    \"host\": [\"localhost\"],
                    \"port\": \"8080\",
                    \"path\": [$(echo "$fullruta" | tr -s '/' '\n' | grep . | sed 's/.*/"&"/' | paste -sd,)]
                  }
                }
              }" >> repositorio-base/postman/coleccion-generada.json
            done
          done
      
          echo "  ]
          }" >> repositorio-base/postman/coleccion-generada.json
      
          echo "‚úÖ Colecci√≥n generada en repositorio-base/postman/coleccion-generada.json"
      

      - name: Commit y push de la nueva funcionalidad (directo a main si todo compila)
        env:
          GH_PAT: ${{ secrets.GH_PAT }}
        run: |
          cd repositorio-base
          git config user.name "github-actions"
          git config user.email "github-actions@github.com"
          git checkout main
      
          git pull origin main  # Asegura que trabajas sobre la √∫ltima versi√≥n de main
      
          git add .
          echo "üìÑ Archivos listos para commitear:"
          git diff --cached --name-status || echo "‚ö†Ô∏è No hay cambios detectados"
      
          if git diff --cached --quiet; then
            echo "‚õî No hay cambios para commitear, se omite push"
            exit 0
          fi
      
          git commit -m "ü§ñ Funcionalidad generada desde historia de usuario"
          git remote set-url origin https://x-access-token:${GH_PAT}@github.com/${{ github.repository }}.git
          git push origin main
  
          